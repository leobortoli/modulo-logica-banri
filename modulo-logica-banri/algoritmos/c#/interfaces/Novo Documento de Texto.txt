Interfaces definem um conjunto de funcionalidades 
relacionadas que podem ser implementadas por classes ou structs.

Elas podem conter métodos estáticos e implementações padrão para membros.

Não podem declarar dados de instância, como campos, 
propriedades automáticas ou eventos semelhantes a propriedades.

Interfaces permitem compor comportamentos de várias 
fontes em uma única classe — algo essencial em C#, 
já que não há herança múltipla de classes.

Também são úteis para simular herança em structs, 
que não podem herdar de outros structs ou classes.

interface IEquatable<T>
{
    bool Equals(T obj);
    // Esse método compara o objeto atual (this) com outro objeto car.
    // A comparação é feita usando tuplas: (Make, Model, Year) == (car?.Make, car?.Model, car?.Year).
    // Isso verifica se todas as três propriedades são iguais entre os dois objetos.
}
// A classe Car tem três propriedades: Make, Model e Year, todas opcionais (string?).
public class Car : IEquatable<Car>
{
    public string? Make { get; set; }
    public string? Model { get; set; }
    public string? Year { get; set; }

    public bool Equals(Car? car)
    {
        return (this.Make, this.Model, this.Year) ==
            (car?.Make, car?.Model, car?.Year);
    }
}

INTERFACES INTERNAS

// Internal type that cannot be exposed publicly
internal class InternalConfiguration
{
    public string Setting { get; set; } = "";
}

// Internal interface that CAN be implemented with public members
// because it only uses public types in its signature
internal interface ILoggable
{
    void Log(string message); // string is public, so this works with implicit implementation
}

// Interface with internal accessibility using internal types
internal interface IConfigurable
{
    void Configure(InternalConfiguration config); // Internal type prevents implicit implementation
}

// This class shows both implicit and explicit interface implementation
public class ServiceImplementation : ILoggable, IConfigurable
{
    // Implicit implementation works for ILoggable because string is public
    public void Log(string message)
    {
        Console.WriteLine($"Log: {message}");
    }

    // Explicit implementation required for IConfigurable because it uses internal types
    void IConfigurable.Configure(InternalConfiguration config)
    {
        // Implementation here
        Console.WriteLine($"Configured with: {config.Setting}");
    }
    
    // If we tried implicit implementation for IConfigurable, this wouldn't compile:
    // public void Configure(InternalConfiguration config) // Error: cannot expose internal type
}